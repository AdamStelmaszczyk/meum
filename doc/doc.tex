\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{hyperref}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage[table]{xcolor}
\title{\textbf{Algorytm ewolucyjny z populacją rosnącą w nieskończoność}}
\author{Adam Stelmaszczyk, Michał Karpiuk}
\date{\today}
\setlength{\parindent}{0in}
\makeatletter\renewcommand{\ALG@name}{}
\renewcommand\refname{Referencje}

\begin{document}
\maketitle

\section{Zadanie}

Celem zadania jest przedstawienie koncepcji, implementacja i testowanie algorytmu ewolucyjnego z populacją rosnącą
w nieskończoność, zawierającą wszystkie punkty wygenerowane do tej pory.

\section{Koncepcja}

Na początku zostanie zaimplementowany podstawowy algorytm ewolucyjny \cite{jarabas}, dalej nazywany AE, 
działający według schematu \ref{ae}:

\begin{algorithm}[!htb]
\label{ae}
\begin{algorithmic}[1]
\Function{ae}{}
  \State $P(0) \gets \{x_1, x_2, \ldots, x_n\}$
  \State $t \gets 0$
  \While{$! stop$}
    \For{$i = 0$ \bf{to} $i = n - 1$}
      \State $a \gets$ selekcja$(\{P(t)\}, U)$
      \State $b \gets$ selekcja$(\{P(t)\}, U)$
      \State $O(t,i) \gets$ mutacja$($krzy{\.z}owanie$(a, b))$
    \EndFor
    \State $P(t+1) \gets$ sukcesja$(P(t), O(t))$
    \State $t \gets t+1$
  \EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

Rozwiązania $\{x_1, x_2, \ldots, x_n\}$ reprezentowane są jako wektor liczb rzeczywistych długości $D$,
gdzie $D$ to liczba wymiarów. Szukanym optimum jest minimum funkcji celu $f(x)$.

\subsection{Mutacja}

Mutacja dodaje szum gaussowski o odchyleniu standardowym do każdej współrzędnej wejściowego rozwiązania.

\begin{algorithm}[!htb]
\begin{algorithmic}[1]
\Function{mutacja}{$x$}
  \For{$i = 0$ \bf{to} $i = D - 1$}
    \State $mutant[i] \gets x[i] + \mathcal{N}(0, 1)$
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Krzyżowanie}

Krzyżowanie otrzymuje na wejściu dwa rozwiązania rodzicielskie $x_1,x_2$ i~zwraca jedno rozwiązanie potomne. 
Wykorzystano krzyżowanie uśredniające.

\begin{algorithm}[!htb]
\begin{algorithmic}[1]
\Function{krzy{\.z}owanie}{$x_1, x_2$}
  \For{$i = 0$ \bf{to} $i = D - 1$}
    \State $potomek[i] \gets \frac{x_1[i] + x_2[i]}{2}$
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Sukcesja}

Sukcesja na wejściu otrzymuje dwie populacje o rozmiarze $n$: aktualną $P$ oraz populację mutantów $O$.
Wyjściem jest jedna populacja o rozmiarze $n$.

\begin{algorithm}[!htb]
\begin{algorithmic}[1]
\Function{sukcesja}{$P, O$}
  \For{$i = 0$ \bf{to} $i = n - 1$}
    \If{$f(O(t, i)) < f(P(t, i)) $}
      \State $P(t+1, i) \gets O(t, i)$
    \Else
      \State $P(t+1, i) \gets P(t, i)$
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Selekcja}

Selekcja otrzymuje na wejściu zbiór populacji $X$. W podstawowym AE przekazywana jest tylko jedna populacja, ta ostatnia, $P(t)$.
Natomiast w AE z populacją rosnącą w nieskończoność, jako zbiór wejściowy przekazywane są wszystkie dotychczasowe populacje.
Selekcja najpierw wybiera z prawdopodobieństwem zgodnym z rozkładem R jedną populację z $X$. Następnie z tej wybranej populacji 
losuje i~zwraca jedno rozwiązanie wylosowane zgodnie z rozkładem jednostajnym.

\begin{algorithm}[!htb]
\begin{algorithmic}[1]
\Function{selekcja}{$X, R$}
  \State $P \gets X[R(0, |X| - 1)]$
  \State $wynik \gets P[\mathcal{U}(0, |P| - 1)]$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{AE z populacją rosnącą w nieskończoność - NAE}

Zmodyfikowany AE będziemy nazywać NAE - nieskończony algorytm ewolucjny, tzn. AE z populacją rosnącą w nieskończoność.
NAE od AE (przedstawionego na schemacie \ref{ae}) różni się jedynie selekcją. W NAE wywołanie operatora selekcji wygląda następująco:

\begin{algorithm}[!htb]
\begin{algorithmic}[1] 
  \State $a \gets$ selekcja$(\{P(0), P(1), \dots, P(t)\}, R)$
  \State $b \gets$ selekcja$(\{P(0), P(1), \dots, P(t)\}, R)$
\end{algorithmic}
\end{algorithm}

Tzn. przekazujemy wszystkie dotychczasowe populacje i jedna z nich zostanie wybrana zgodnie z rozkładem $R$.
Następnie z tej wybranej populacji zostanie wylosowane jedno rozwiązanie zgodnie z rozkładem jednostajnym.
Wersji NAE może być nieskończenie wiele, w zależności od wybranego rozkładu $R$. 
W tej pracy zakładamy, ze funkcja gęstości prawdopodobieństwa rozkładu $R$ jest postaci $at^w + b$, gdzie
$a, b, w \in \mathbb{R}$ to nieujemne parametry, zaś $t \in \mathbb{N} \cup \{0\}$ to numer populacji. 

\section{Testowanie}

Porównano następujące algorytmy:

\begin{enumerate}
 \item AE, podstawowy algorytm ewolucyjny opisany schematem \ref{ae}.
 \item NAEU, NAE z rozkładem jednostajnym $\mathcal{U}$, $a=0$,
czyli funkcja postaci $\frac{1}{b}$. 
 \item NAEP, rozkład o pierwiastkowej funkcji gęstości prawdopodobieństwa, \\$a>0, b=0, w=\frac{1}{2}$,
czyli funkcja postaci $a\sqrt{t}$.
 \item NAEL, rozkład o liniowej funkcji gęstości prawdopodobieństwa, $a>0, b=0, w=1$,
czyli funkcja postaci $at$.
 \item NAEK, rozkład o kwadratowej funkcji gęstości prawdopodobieństwa, \\$a>0, b=0. w=2$,
czyli funkcja postaci $at^2$.
\end{enumerate}

Przyjmując, że jesteśmy w populacji $T$, prawdopodobieństwo wylosowania populacji $t$ wynosi:
\begin{enumerate}
 \item 1 dla $t=T$, 0 dla $t \neq T$.
 \item $\frac{1}{T}$.
 \item $\frac{6\sqrt{t}}{(4T+1)\sqrt{T+1}}$.
\footnote{Szukamy takiego $a$, dla którego $\sum\limits_{t=0}^T a\sqrt{t} = 1$. Zatem $a = \frac{1}{1 + \sqrt{2} + \dots + \sqrt{T}}$. 
Suma w mianowniku jest równa $\frac{1}{6}(4T+1)\sqrt{T+1}$ z dokładnością do 0,5 \cite{snehal}.}
 \item $\frac{2t}{T(T+1)}$.
 \item $\frac{6t^2}{T(T+1)(2T+1)}$.
\end{enumerate}

Eksperymenty przeprowadzono na 7 funkcjach testowych o numerach 15, 16, 19, 20, 21, 22, 24 z BBOB 2013 \cite{finck, hansen}, 
zaimplementowanych w języku C.
Funkcje testowe są wywoływane z Javy, w której napisano algorytmy oraz procedurę testującą.
Liczba wymiarów $D \in \{10, 20, 40\}$. Maksymalna liczba wywołań funkcji oceny $FEs = 10^5D$. 
Rozmiar populacji $n = 10D$. Jeśli algorytm nie znajdował minimum, wówczas w jednym uruchomieniu, na jednej funkcji, 
generował $\frac{FEs}{n} = 10^4$ pokoleń. 
Na każdej funkcji algorytm był niezależnie uruchamiany 15 razy, z każdego uruchomienia zapisywany był najlepszy wynik. \\
\\
W celu porównania, wykreślano dystrybuanty empiryczne najlepszych wyników z każdego uruchomienia 
algorytmów na jednej funkcji. Najlepszym wynikiem jest najmniejsza różnica funkcji oceny dowolnego rozwiązania od minimum.
Algorytm, którego dystrybuanta na wykresie przebiegała powyżej pozostałych, otrzymywał 4 punkty. 
Za drugie miejsce algorytm otrzymywał 3 punkty, za trzecie 2, za czwarte 1, za ostatnie 0. 
Jeśli dystrybuanty się przecinały, algorytmy zajmowały i-te miejsce ex aequo i otrzymywały punkty za i-te miejsce.

\nocite{*}
\bibliographystyle{plain}
\bibliography{references}
\end{document}
